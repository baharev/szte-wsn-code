
for { i in COORDS, j in COORDS } {

  let gyroGain_L[i,j] := if i>=j then gyroGain_0[i,j]-0.003 else gyroGain_0[i,j];
  let gyroGain_U[i,j] := if i>=j then gyroGain_0[i,j]+0.003 else gyroGain_0[i,j];

  let gyroOffset_L[i] := -15;
  let gyroOffset_U[i] :=  -5;

}

# printf "\nROT_ERROR\n";
# for {s in SAMPLES}
#   print s," ",variable[s,ROT_ERROR,0,0];
# 
# printf "\nCALIBRATED_GYRO\n";
# for {s in SAMPLES}
#   print s," ",variable[s,CALIBRATED_GYRO,1,0],variable[s,CALIBRATED_GYRO,2,0],variable[s,CALIBRATED_GYRO,3,0];

#display { s in SAMPLES } : variable[s,ROT_ERROR,0,0];

display total;

#for {s in SAMPLES, i in COORDS, j in COORDS } print "sample",s,"i, j",i,j,"value",variable[s,ROT_ORTHOGONAL,i,j];

# print "";
# print "CALIBRATED_GYRO";
# for {s in SAMPLES}
#   print "s",s,"v",variable[s,CALIBRATED_GYRO,1,0],variable[s,CALIBRATED_GYRO,2,0],variable[s,CALIBRATED_GYRO,3,0];
# 
# print "";
# print "ROTATION_MATRIX";
# for {s in SAMPLES, i in COORDS}
#   print "s",s,"i",i,variable[s,ROTATION_MATRIX,i,1],variable[s,ROTATION_MATRIX,i,2],variable[s,ROTATION_MATRIX,i,3];
# 
# print "";
# print "ROT_DELTA";
# for {s in SAMPLES, i in COORDS}
#   print "s",s,"i",i,variable[s,ROT_DELTA,i,1],variable[s,ROT_DELTA,i,2],variable[s,ROT_DELTA,i,3];
# 
# print "";
# print "ROT_UPDATE";
# for {s in SAMPLES, i in COORDS} 
#   print "s",s,"i",i,variable[s,ROT_UPDATE,i,1],variable[s,ROT_UPDATE,i,2],variable[s,ROT_UPDATE,i,3];
# 
# print "";
# print "ROT_ORTHOGONAL";
# for {s in SAMPLES, i in COORDS, j in COORDS } print "s",s,"i",i,"j",j,"v",variable[s,ROT_ORTHOGONAL,i,j];

option show_stats 1;

option solver "/home/ali/ampl/ipopt";

solve;

display gyroGain;

display gyroOffset;

# print "";
# print "ROT_ERROR";
# for {s in SAMPLES}
#   print "s",s,variable[s,ROT_ERROR,0,0];
